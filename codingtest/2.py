# 문제 설명
# 한 슈퍼마켓에서 기네스북에 등재를 위해 세상에서 가장 큰 피자를 만들었습니다. 기네스북 등재를 마친 후에 피자 시식 행사를 하기로 했습니다. 이 슈퍼마켓에서 만든 피자는 아래 그림과 같이 N 조각으로 피자를 나눈 후, 각 조각에 서로 다른 토핑을 올리되, 같은 토핑이 올라가 있는 조각이 2개씩 있도록 했습니다. 즉, N 조각으로 나누어진 피자 위에는 서로 다른 N/2개의 토핑이 올라가 있습니다. 아래 그림은 N = 8인 경우의 예시입니다.

# 피자2_wjklce.png

# 위 그림에서 피자는 전체 8조각으로 나누어져 있으며, 각 조각별로 1번부터 8번까지 번호가 붙어있습니다. 피자 위의 토핑 또한 1번부터 4번까지 번호가 붙어있으며, 같은 토핑이 올라간 조각은 2개씩 존재합니다. 이 피자의 토핑을 시식하기 위해서는 각 번호가 쓰여 있는 칸들을 피자 둘레를 따라 걸어서 이동해야 하는데, 한 칸 이동하는 데는 1 만큼의 단위 시간이 소요됩니다.
# 이 행사에 참석한 철수는 현재 1번 위치에 서 있습니다. 각 피자 조각을 시식하되, 미리 시식할 토핑 번호의 순서를 정해두었습니다.

# 예를 들어 철수가 미리 정한 순서가 [1번 토핑, 2번 토핑, 3번 토핑, 4번 토핑]이라면 위치1에서 시작해서 → 위치2 → 위치1 → 위치8 → 위치7 순서로 이동하여 총 4의 단위 시간 만에 시식을 할 수 있습니다.
# 만약 철수가 미리 정한 순서가 [3번 토핑, 1번 토핑, 2번 토핑, 4번 토핑]이라면 위치1에서 시작해서 → 위치8 → 위치2 → 위치1 → 위치7의 순서로 이동할 경우 6의 단위 시간에 모두 시식할 수 있지만, 위치1에서 시작해서 → 위치3 → 위치4 → 위치5 → 위치6 순서로 이동하면 5의 단위 시간에 모두 시식할 수 있습니다.
# 이때, 철수가 시식하는데 드는 시간은 무시하며, 이동시간만 고려합니다 .
# 철수는 시식 순서를 건너뛰는 일이 없이 반드시 미리 정해둔 순서대로 시식합니다. 시식 순서에는 같은 번호의 토핑을 여러 번 넣어두었을 수도 있습니다. 하지만, 피자는 매우 크기 때문에 철수가 조금 시식한다고 해서 없어지지 않습니다. 따라서 같은 위치에서 몇 번이든 시식할 수 있습니다. 또, 같은 번호의 토핑을 연속으로 시식할 때는 굳이 자리를 이동하지 않아도 됩니다.

# 현재 피자 위에 올라가 있는 토핑의 순서 topping, 철수가 시식하려는 순서 tasting이 매개변수로 주어질 때, 철수가 모든 토핑을 시식하는데 걸리는 이동시간의 최솟값을 return 하도록 solution 함수를 완성해 주세요.

# 제한사항
# topping은 피자 위의 각 칸의 토핑 번호가 순서대로 들어있는 배열이며, 길이(N)는 2 이상 300 이하의 짝수입니다.
# topping의 첫 번째 원소에는 1번 위치의 토핑 번호가 들어있으며, 이후 순서대로 N 번 위치까지의 토핑 번호가 들어있습니다. 둥근 피자 모양을 위해 topping의 첫 번째 원소와 마지막 원소가 이어져 있다고 가정합니다.
# topping에 들어있는 각 원소는 1 이상 N/2 이하의 자연수입니다.
# tasting은 철수가 토핑을 시식하려는 순서가 들어있는 배열이며, 길이는 1 이상 300 이하입니다.
# tasting의 각 원소는 철수가 시식하려는 토핑의 번호로, 1 이상 N/2 이하의 자연수입니다.
# return 값은 모든 토핑을 시식하는 각 방법이 걸리는 시간 중에서 최소 시간입니다.
# 입출력 예
# topping   tasting   result
# [2,1,3,1,2,4,4,3]   [1,2,3,4]   4
# [2,1,3,1,2,4,4,3]   [3,1,2,4]   5
# 입출력 예 설명
# 입출력 예 #1
# 문제의 예시와 같습니다.

# 입출력 예 #2
# 문제의 예시와 같습니다.

#BFS 문제 이다